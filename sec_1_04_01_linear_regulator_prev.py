"""Ngspice Session: sec_1_04_01_linear_regulator"""

# region imports
import os
from pathlib import Path

# from typing import TypeAlias
# import numpy as np
# import numpy.typing as npt
import py4spice as spi
from py4spice import AnaType


# import matplotlib.pyplot as plt
# import matplotlib.figure as fig

# Alias for type checking
# numpy_flt: TypeAlias = npt.NDArray[np.float64]


# endregion

# region Constants and directories

# Path to NGSPICE, KiCad
NGSPICE_EXE = Path("c:/Program Files/ngspice_40/bin/ngspice_con.exe")
KICAD_EXE = Path("c:/Program Files/KiCad/7.0/bin/kicad-cli.exe")

# Path to my project (divided into 3 strings for readability)
PATH_0 = "G:/My Drive/_TechSharpen/ngspice_work/projects/switched_pwr_book/simulation_examples/"
PATH_1 = "sec_1_04_01_linear_regulator"
PATH_2 = "/ngspice"
PROJ_PATH_ABS = Path(PATH_0 + PATH_1 + PATH_2)

# Create a relative path to the project directory
PROGRAM_PATH = Path(os.curdir)
PROJ_PATH_REL = Path(os.path.relpath(PROJ_PATH_ABS, PROGRAM_PATH))

# netlist generated by KiCad
KICAD_SCH_FILENAME = PROJ_PATH_REL / "schematics/my_schematic/my_schematic.kicad_sch"
KICAD_NETLIST_FILENAME = PROJ_PATH_REL / "schematics/my_schematic/circ.cir"

# need relative paths for ngspice command to execute correctly
NETLISTS_PATH_REL = PROJ_PATH_REL / "netlists"
RESULTS_PATH_REL = PROJ_PATH_REL / "results"
if not RESULTS_PATH_REL.exists():
    RESULTS_PATH_REL.mkdir()

# netlist file names
TOP = "top.sp"
TOP_FILENAME = NETLISTS_PATH_REL / TOP
CONTROL = "control.sp"
CONTROL_FILENAME = NETLISTS_PATH_REL / CONTROL
DUT = "dut.sp"
DUT_FILENAME = NETLISTS_PATH_REL / DUT

# types of analysis output data
TABLE_DATA: list[AnaType] = ["op", "sens", "tf"]
PLOT_DATA: list[AnaType] = ["ac", "dc", "disto", "noise", "pz", "sp", "tran"]


# define vectors ("signals") to look at
VEC_ALL = spi.Vectors("all")
VEC_IN_OUT = spi.Vectors(["in", "out1", "out2"])
VEC_ALL_EXPANDED = spi.Vectors(
    [
        "in",
        "out1",
        "out1_meas",
        "out2",
        "out2_meas",
        "vee",
        "vee#branch",
        "vin#branch",
        "vmeas1#branch",
        "vmeas2#branch",
    ]
)
VEC_VIN = spi.Vectors("in")
VEC_IIN = spi.Vectors("vin#branch")
VEC_VOUT1 = spi.Vectors("out1")
VEC_VOUT2 = spi.Vectors("out2")
VEC_IOUT1 = spi.Vectors("vmeas1#branch")
VEC_IOUT2 = spi.Vectors("vmeas2#branch")

# endregion

# region Functions


def kicad_netlist() -> None:
    """Parse the netlist from KiCad. remove first and last lines, and
    remove forward slashes from node names.
    """
    # extract netlist from schematic into dir with schematic
    netlist_extract = spi.KicadCmd(
        KICAD_EXE, KICAD_SCH_FILENAME, KICAD_NETLIST_FILENAME
    )
    spi.print_section("KiCad Export Netlist Command", netlist_extract)
    netlist_extract.run()

    # convert Kicad spice netlist and move to netlist directory
    my_dut = spi.Netlist(KICAD_NETLIST_FILENAME)
    my_dut.remove_first_last_lines()
    my_dut.remove_forwardslashes()
    my_dut.writefile(DUT_FILENAME)

    # print to check netlist content
    spi.print_section("DUT Netlist", my_dut)


def define_analyses() -> list[spi.Analyses]:
    """define all the analyses to simulate

    Returns:
        list[spi.Analyses]: list of analyses
    """
    list_of_analyses: list[spi.Analyses] = []

    # 1st analysis
    op_cmd = "op"
    op1 = spi.Analyses("op1", "op", op_cmd, VEC_ALL, RESULTS_PATH_REL)
    list_of_analyses.append(op1)

    return list_of_analyses


def construct_control(all_analyses: list[spi.Analyses]) -> None:
    """Create the control file before simulation"""
    my_control = spi.Control()  # create 'my_control' object
    my_control.insert_lines(["listing"])  # cmd to list out netlist
    for analysis in all_analyses:  # statements for all analyses
        my_control.insert_lines(analysis.lines_for_cntl())
    spi.print_section("Control File", my_control)  # print out contents
    my_control.content_to_file(CONTROL_FILENAME)  # creat the actual file


def sim_to_numpys(the_analyses: list[spi.Analyses]) -> list[spi.Signals]:
    """Simulate and convert results to numpy arrays
    Args:
        the_analyses (list[spi.Analyses]): the analysis we'll simulate
    Returns:
        list[spi.SimResults]: list of results for each analysis simulated
    """
    # prepare simulate object, print out command, and simulate
    sim1 = spi.Simulate(NGSPICE_EXE, TOP_FILENAME)
    spi.print_section("Ngspice Command", sim1)
    sim1.run()  # run the Ngspice simulation
    text_file_results = RESULTS_PATH_REL / f"{the_analyses[0].name}.txt"
    sim_results = []
    sim_results.append(spi.Signals.from_spice_table(text_file_results))
    return sim_results


def analyze_results(sim_results: list[spi.Signals]) -> None:
    """Analyze and and display results"""
    op1 = sim_results[0]
    op1_values = op1.signals_table(VEC_ALL_EXPANDED.list_out)
    spi.print_section("Operating Point Results", op1_values)

    vin = op1.signal_value(str(VEC_VIN))
    iin = -1 * op1.signal_value(str(VEC_IIN))
    vout1 = op1.signal_value(str(VEC_VOUT1))
    vout2 = op1.signal_value(str(VEC_VOUT2))
    iout1 = op1.signal_value(str(VEC_IOUT1))
    iout2 = op1.signal_value(str(VEC_IOUT2))
    pr1 = (vin - vout1) * iout1
    pr2 = (vin - vout2) * iout2
    pout1 = vout1 * iout1
    pout2 = vout2 * iout2
    pout = pout1 + pout2
    pin = vin * iin
    eta = pout / pin

    print(f"p1 = {pr1:.4g}W")
    print(f"p2 = {pr2:.4g}W")
    print(f"pout1 = {pout1:.4g}W")
    print(f"pout2 = {pout2:.4g}W")
    print(f"pout = {pout:.4g}W")
    print(f"pin = {pin:.4g}W")
    print(f"eta = {eta*100:.4g}%")


# endregion


def main() -> None:
    """Main"""

    # create netlist from KiCad
    kicad_netlist()

    # define my analyses to run. Pass in vector set for each analysis
    my_analyses: list[spi.Analyses] = define_analyses()

    # construct the control file
    construct_control(my_analyses)

    # simulate and convert results to objects of numpy format
    sim_results = sim_to_numpys(my_analyses)

    # analyze and display results
    analyze_results(sim_results)


if __name__ == "__main__":
    main()
