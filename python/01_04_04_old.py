"""Ngspice Session"""

# region imports
import os
from pathlib import Path
import copy
from typing import TypeAlias
import numpy as np
import numpy.typing as npt
import py4spice as spi
from py4spice import AnaType


# import matplotlib.pyplot as plt
# import matplotlib.figure as fig

# Alias for type checking
numpy_flt: TypeAlias = npt.NDArray[np.float64]


# endregion

# region Constants and directories

# Path to NGSPICE, KiCad
NGSPICE_EXE = Path("c:/Program Files/ngspice_40/bin/ngspice_con.exe")
KICAD_EXE = Path("c:/Program Files/KiCad/7.0/bin/kicad-cli.exe")

# Path to my project (divided into 3 strings for readability)
PROJ_PATH_0 = "G:/My Drive/_TechSharpen/ngspice_work/projects/"
PROJ_PATH_1 = "switched_pwr_book/simulation_examples/"
PROJ_PATH_2 = "sec_1_04_04_linear_regulator/ngspice"
PROJ_PATH_ABS = Path(PROJ_PATH_0 + PROJ_PATH_1 + PROJ_PATH_2)

# Create a relative path to the project directory
PROGRAM_PATH = Path(os.curdir)
PROJ_PATH_REL = Path(os.path.relpath(PROJ_PATH_ABS, PROGRAM_PATH))

# netlist generated by KiCad
KICAD_SCH_FILENAME = PROJ_PATH_REL / "schematics/my_schematic/my_schematic.kicad_sch"
KICAD_NETLIST_FILENAME = PROJ_PATH_REL / "schematics/my_schematic/circ.cir"

# need relative paths for ngspice command to execute correctly
NETLISTS_PATH_REL = PROJ_PATH_REL / "netlists"
RESULTS_PATH_REL = PROJ_PATH_REL / "results"
if not RESULTS_PATH_REL.exists():
    RESULTS_PATH_REL.mkdir()

# netlist file names
TOP = "top.sp"
TOP_FILENAME = NETLISTS_PATH_REL / TOP
CONTROL = "control.sp"
CONTROL_FILENAME = NETLISTS_PATH_REL / CONTROL
DUT = "dut.sp"
DUT_FILENAME = NETLISTS_PATH_REL / DUT

# types of analysis output data
TABLE_DATA: list[AnaType] = ["op", "sens", "tf"]
PLOT_DATA: list[AnaType] = ["ac", "dc", "disto", "noise", "pz", "sp", "tran"]


# define vectors ("signals") to look at
VEC_ALL = spi.Vectors("all")
VEC_IN_OUT = spi.Vectors(["in", "out"])
VEC_INTEREST = spi.Vectors("in vee out")
VEC_OUT = spi.Vectors("out")
# endregion


# region Functions
def kicad_netlist(
    kicad_exe: Path,
    sch_filename: Path,
    netlist_filename: Path,
    dut_filename: Path,
) -> None:
    """Parse the netlist from KiCad. remove first and last lines, and
    remove forward slashes from node names.
    """
    # extract netlist from schematic into dir with schematic
    netlist_extract = spi.KicadCmd(kicad_exe, sch_filename, netlist_filename)
    spi.print_section("KiCad Export Netlist Command", netlist_extract)
    netlist_extract.run()

    # convert Kicad spice netlist and move to netlist directory
    my_dut = spi.Netlist(netlist_filename)
    my_dut.remove_first_last_lines()
    my_dut.remove_forwardslashes()
    my_dut.writefile(dut_filename)

    # print to check netlist content
    spi.print_section("DUT Netlist", my_dut)


def define_analyses(
    results_path: Path, vectors: list[spi.Vectors]
) -> list[spi.Analyses]:
    """define all the analyses to simulate

    Returns:
        list[spi.Analyses]: list of analyses
    """
    vec_op = vectors[0]
    vec_tf = vectors[1]
    vec_tr = vectors[2]

    list_of_analyses: list[spi.Analyses] = []

    # 1st analysis
    op_cmd = "op"
    op1 = spi.Analyses("op1", "op", op_cmd, vec_op, results_path)
    list_of_analyses.append(op1)

    # 2nd analysis
    tf_cmd = "tf v(out) vin"
    tf1 = spi.Analyses("tf1", "tf", tf_cmd, vec_tf, results_path)
    list_of_analyses.append(tf1)

    # 3rd analysis
    tr_cmd = "tran 1e-9 20e-6"
    tr1 = spi.Analyses("tr1", "tran", tr_cmd, vec_tr, results_path)
    list_of_analyses.append(tr1)

    return list_of_analyses


def construct_control(all_analyses: list[spi.Analyses], control_filename: Path) -> None:
    """something"""
    my_control = spi.Control()  # create 'my_control' object
    my_control.insert_lines(["listing"])  # cmd to list out netlist
    for analysis in all_analyses:  # statements for all analyses
        my_control.insert_lines(analysis.lines_for_cntl())
    spi.print_section("Control File", my_control)  # print out contents
    my_control.content_to_file(control_filename)  # creat the actual file


def sim_to_numpys(
    the_analyses: list[spi.Analyses], ngspice_exe: Path, top_filename: Path
) -> list[spi.SimResults]:
    """convert"""

    # prepare simulate object, print out command, and simulate
    sim1 = spi.Simulate(ngspice_exe, top_filename)
    spi.print_section("Ngspice Command", sim1)
    sim1.run()
    sim_results = [
        spi.SimResults.from_file(analysis.cmd_type, analysis.results_filename)
        for analysis in the_analyses
    ]
    return sim_results


def plot_tr(
    sim_result: spi.SimResults, vectors_to_plot: spi.Vectors, results_path: Path
) -> None:
    """plot tranisent results"""

    # x-axis and signals in list of numpys
    plot_data = sim_result.x_axis_and_sigs(vectors_to_plot.list_out)
    y_names = vectors_to_plot.list_out

    plt_tr = spi.Plot("tr_plt", plot_data, y_names, results_path)
    plt_tr.set_title("transient results")
    plt_tr.define_axes(("time", "sec", "linear"), ("voltage", "V", "linear"))
    # plt_tr.zoom(8e-6, 12e-6)

    spi.display_plots()


# endregion


def main() -> None:
    """Main"""

    # create netlist from KiCad
    kicad_netlist(KICAD_EXE, KICAD_SCH_FILENAME, KICAD_NETLIST_FILENAME, DUT_FILENAME)

    # define my analyses to run. Pass in vector set for each analysis
    my_analyses: list[spi.Analyses] = define_analyses(
        RESULTS_PATH_REL, [VEC_ALL, VEC_ALL, VEC_ALL]
    )

    # construct the control file
    construct_control(my_analyses, CONTROL_FILENAME)

    # simulate and convert results to objects of numpy format
    op1, tf1, tr1 = sim_to_numpys(my_analyses, NGSPICE_EXE, TOP_FILENAME)

    # display the results
    spi.print_section("Operating Point Results", op1.print_table())
    spi.print_section("Small Signal DC Transfer", tf1.print_table())
    # plot_tr(tr1, VEC_IN_OUT, RESULTS_PATH_REL)

    tr2 = copy.deepcopy(tr1)
    tr2.vec_subset(VEC_OUT.list_out)  # limit to just "out" signal
    # tr2.x_range(9e-6, 12e-6, 1000)  # limit range to just step results
    # print(repr(tr2))
    # plot_tr(tr2, VEC_OUT, RESULTS_PATH_REL)

    tr2_numpys: list[numpy_flt] = tr2.x_axis_and_sigs(VEC_OUT.list_out)

    my_meas = spi.StepInfo(tr2_numpys[0], tr2_numpys[1], 9e-6, 12e-6, 10000)
    print(f"yinit = {my_meas.yinit}")
    print(f"yfinal = {my_meas.yfinal}")
    print(f"ydelta = {my_meas.ydelta}")
    print(f"ylo = {my_meas.ylo}")
    print(f"ymid = {my_meas.xmid}")
    print(f"yhi = {my_meas.yhi}")
    print(f"xlo = {my_meas.xlo}")
    print(f"xmid = {my_meas.xmid}")
    print(f"xhi = {my_meas.xhi}")
    print(f"risetime = {my_meas.risetime}")
    print(f"peak = {my_meas.peak}")
    print(f"peaktime = {my_meas.peaktime}")
    print(f"xinit = {my_meas.xinit}")
    print(f"settlingtime = {my_meas.settlingtime}")
    my_y_val = my_meas.y_at_x(10.5e-6)
    print(f"y_value = {my_y_val}")


if __name__ == "__main__":
    main()
